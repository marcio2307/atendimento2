<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Chat + Tarot (tempo real)</title>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@600;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{
      --vh: 1vh;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-top: env(safe-area-inset-top, 0px);
    }
    *{box-sizing:border-box}
    body { font-family: Arial, sans-serif; background: #1d1f21; margin: 0; padding: 0; color: #111; }

    /* ====== FILA ====== (cliente não vê) */
    .fila-container {
      max-width: 500px; margin: 16px auto 8px auto; background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      border-radius: 14px; padding: 12px; box-shadow: 0 6px 20px rgba(0,0,0,0.25);
      display: flex; align-items: center; gap: 12px; justify-content: space-between; color: #e5e7eb; border:1px solid #2a2f36;
    }
    .fila-info { display:flex; align-items:center; gap:10px; }
    .bolinha { width:10px; height:10px; border-radius:50%; background:#00c800; animation: piscar 1s infinite; }
    .chip { display:flex; align-items:center; justify-content:center; min-width:36px; height:28px; background:#111827; padding:0 10px; border-radius:20px; color:#e5e7eb; font-size:14px; font-weight:700; border:1px solid #374151;}
    .fila-actions { display:flex; gap:10px; }
    .btn-proximo, .btn-timer {
      display:inline-flex; align-items:center; gap:8px;
      background:#016e35; color:#fff; border:none; padding:10px 14px; border-radius:10px; cursor:pointer; font-size:14px; font-weight:700;
      box-shadow: 0 6px 14px rgba(1,110,53,.28);
      transition: transform .06s ease, box-shadow .2s ease, background .2s ease;
    }
    .btn-proximo:hover, .btn-timer:hover{ transform: translateY(-1px); box-shadow: 0 10px 18px rgba(1,110,53,.33); }
    .btn-timer.stop{ background:#b91c1c; box-shadow: 0 6px 14px rgba(185,28,28,.28); }
    .btn-timer .dot{ width:8px; height:8px; border-radius:50%; background:#fff; box-shadow:0 0 0 0 rgba(255,255,255,.6); }
    .btn-timer.stop .dot{ animation: pulseDot 1.2s infinite; }
    @keyframes pulseDot{ 0%{box-shadow:0 0 0 0 rgba(255,255,255,.5)} 70%{box-shadow:0 0 0 8px rgba(255,255,255,0)} 100%{box-shadow:0 0 0 0 rgba(255,255,255,0)}}

    body[data-role="cliente"] .fila-container { display: none !important; }

    /* ====== CHAT ====== */
    .chat-container {
      width: 100%;
      max-width: 500px;
      height: calc(var(--vh) * 100);
      margin: 0 auto 12px auto;
      background: #f7f7f7;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0,0,0,0.25);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    /* ====== CABEÇALHO ====== */
    .chat-header {
      position: sticky; top: 0; z-index: 2;
      display: flex; align-items: center; gap: 10px;
      background:#ffffff; padding: 12px 12px calc(12px + var(--safe-top));
      color:#0f172a;
      border-bottom:1px solid #e5e7eb;
      box-shadow: 0 1px 3px rgba(0,0,0,.08);
    }
    .chat-header strong { font-size: 16px; }
    .timer {
      font-size: 14px; margin-left: auto; color:#0f172a;
      display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
      background: rgba(15,23,42,.06); border:1px solid rgba(15,23,42,.12);
      box-shadow: inset 0 0 6px rgba(0,0,0,.04);
    }
    .timer.running{ animation: pulseTimer 2s ease-in-out infinite; }

    .btn-som{ margin-left: 8px; background:#e5e7eb; color:#0f172a; border:none; padding:6px 10px; border-radius:6px; cursor:pointer; font-size:14px; }
    .btn-som.off{ background:#d1d5db; color:#111827; }

    /* Avatar + anel */
    .chat-header .avatar{
      width: 56px; height: 56px; border-radius: 50%;
      border: 2px solid #ffffff;
      box-shadow: 0 1px 2px rgba(0,0,0,.15);
      object-fit: cover; background:#e5e7eb; flex: 0 0 auto;
      cursor: pointer; transition: box-shadow .2s ease;
    }
    .chat-header .avatar.online{
      box-shadow:
        0 0 0 3px #22c55e,
        0 0 0 6px #ffffff,
        0 2px 4px rgba(0,0,0,.18);
    }

    .chat-body {
      flex: 1;
      overflow-y: auto; overflow-x: hidden;
      padding: 10px 12px 16px;
      background-color: #eae6df;
      background-image: url("imagem/papel-tarot.png");
      background-repeat: repeat;
      background-size: 520px auto;
      background-attachment: fixed;
      background-position: center;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overscroll-behavior: contain;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: auto;
    }

    .center-row { margin: auto; display: none; justify-content: center; align-items: center; width: 100%; }

    .message { margin: 2px 0; display: flex; align-items: flex-end; }
    .message.attendant { justify-content: flex-end; }
    .message.client { justify-content: flex-start; }

    /* ===== Balão único (texto, imagem e áudio) ===== */
    .message .bubble{
      position: relative;
      padding: 10px 12px;
      border-radius: 12px;
      max-width: 82%;
      line-height: 1.35;
      box-shadow: 0 1px 0 rgba(0,0,0,.06);
      display: inline-block;
      word-wrap: break-word;
      overflow-wrap: anywhere;
      transition: transform .18s ease, box-shadow .18s ease; /* (drag) */
      will-change: transform;
      touch-action: pan-y;            /* gesto horizontal + scroll vertical */
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    .message.attendant .bubble{ background:#d9fdd3; color:#111; border-bottom-right-radius:4px; }
    .message.client .bubble{ background:#fff; color:#222; border-bottom-left-radius:4px; }

    /* === Alinhamento “quem envia → direita” === */
    .message.mine{ justify-content: flex-end !important; }
    .message.theirs{ justify-content: flex-start !important; }
    .message.mine .bubble{
      background:#d9fdd3; color:#111; border-bottom-right-radius:4px; border-bottom-left-radius:12px;
      margin-left:auto; margin-right:4px;
    }
    .message.theirs .bubble{
      background:#fff; color:#222; border-bottom-left-radius:4px; border-bottom-right-radius:12px;
      margin-right:auto; margin-left:4px;
    }
    .bubble.dragging{ box-shadow: 0 6px 18px rgba(0,0,0,.15); }

    /* botão flutuante de lixeira (aparece ao tocar no balão) */
    .trash-pop{
      position: absolute;
      top: -10px;
      right: -10px;
      z-index: 3;
      border: none;
      border-radius: 999px;
      width: 36px; height: 36px;
      display: grid; place-items: center;
      background: #ef4444; color: #fff; cursor: pointer;
      box-shadow: 0 8px 20px rgba(239,68,68,.35);
      transform: scale(.9);
      opacity: 0; pointer-events: none;
      transition: transform .16s ease, opacity .16s ease;
    }
    .bubble.show-trash .trash-pop{ opacity: 1; pointer-events: auto; transform: scale(1); }

    /* pista visual do swipe (setinha) — opcional */
    .bubble::before{
      content: '';
      position: absolute; left: -14px; top: 50%;
      width: 8px; height: 8px; border-top: 2px solid rgba(0,0,0,.15);
      border-left: 2px solid rgba(0,0,0,.15);
      transform: translateY(-50%) rotate(-45deg);
      opacity: 0; transition: opacity .15s ease;
    }
    .bubble.swipe-hint::before{ opacity: 1; }

    /* Conteúdo interno herda o balão */
    .message .text{ margin:0; padding:0; background:transparent; white-space:pre-wrap; }
    .message .image{ margin:0; padding:0; background:transparent; }
    .message .image img, .message .image canvas{ display:block; width:100%; height:auto; border-radius:8px; }

    /* Áudio dentro do balão e sempre alinhado ao lado do remetente */
    .message .audio-wrap{
      margin:0; padding:0; background:transparent;
      display:flex; gap:8px; align-items:center; justify-content:flex-end;
      max-width:100%;
    }
    .message .audio-wrap audio{ width: 240px; max-width: 100%; }

    .reply-quote{
      font-size: 12px; opacity: .85; padding:6px 8px; border-left:3px solid #7c3aed; border-radius:8px; background: rgba(124,58,237,.06); margin-bottom:6px;
      max-width: 100%;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }

    .audio-toolbar{ display:inline-flex; gap:6px; align-items:center; }
    .rewind-btn{
      border:none; background:rgba(0,0,0,.06); padding:6px 8px; border-radius:8px; cursor:pointer; font-size:14px;
    }
    .rewind-btn:hover{ filter:brightness(0.95); }
    .message .audio-wrap .duration { font-size: 11px; opacity: .7; }

    .typing { font-size: 12px; color: #666; margin: -6px 0 6px 6px; }

    .meta { font-size: 11px; color:#1d78f0; margin-top: 4px; display: flex; align-items: center; gap: 6px; }
    .receipt { display:inline-flex; gap:2px; line-height: 1; user-select: none; }
    .receipt .check { font-weight: 900; opacity: .65; }
    .receipt.seen .check { color: #1d9bf0; opacity: 1; }

    .chat-footer {
      position: sticky; bottom: 0; z-index: 2;
      display: grid !important;
      grid-template-columns: 42px 1fr 48px;
      align-items: center; gap: 8px;
      border-top: 1px solid #ddd; background: #f7f7f7;
      padding: 8px 8px calc(8px + var(--safe-bottom));
    }

    /* Barra de resposta */
    .reply-bar{
      grid-column: 1 / -1;
      display:none; align-items:center; gap:10px;
      background:#fff; border:1px dashed #c4b5fd; border-radius:10px; padding:6px 10px; margin: 6px 0 2px;
    }
    .reply-bar .excerpt{ flex:1; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .reply-cancel{ background:transparent; border:none; font-size:18px; cursor:pointer; }

    .chat-footer input[type="text"] { flex: 1; padding: 12px; border: none; outline: none; font-size: 15px; border-radius: 8px; background:#fff; }
    .chat-footer button { background: #016e35; border: none; color: white; padding: 10px 16px; cursor: pointer; font-size: 14px; border-radius: 8px; }
    .icon-btn { width:42px; height:42px; border-radius: 50%; display:grid; place-items:center; padding:0; }
    .icon-btn.secondary{ background:#e5e7eb; color:#111; }
    .icon-btn.rec.on{ background:#b91c1c; color:#fff; animation: pulseRec 1s infinite; }
    .icon-btn.rec.on::after{ content:""; width:6px; height:6px; border-radius:50%; background:#fff; position:absolute; top:8px; right:8px; }
    @keyframes pulseRec{ 0%{transform:scale(1)} 50%{transform:scale(1.05)} 100%{transform:scale(1)} }

    /* Botão encerrar */
    #endBtn { background: #b91414; padding: 10px 15px; border: none; color: white; margin: 10px; border-radius: 6px; cursor: pointer; width: calc(100% - 20px); }
    body[data-role="cliente"] #endBtn { display:none !important; }
    #chat-ended { text-align: center; padding: 20px; color: #016e35; font-weight: bold; display: none; }

    @keyframes piscar { 0%{opacity:1} 50%{opacity:0} 100%{opacity:1} }

    /* ====== TAROT ====== */
    body[data-role="cliente"] #lenRootWrap,
    body[data-role="cliente"] .tarot-actions { display: none !important; }
    #lenRoot{ --gap:26px; background: transparent; }
    .layout{display:block}
    .board{ padding:20px 14px 10px; display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:var(--gap); justify-items:center; }
    .slot{ display:grid; place-items:center; width:100%; }
    .card{ width:clamp(100px,28vw,140px); aspect-ratio:62/100; position:relative; border-radius:16px;
           transform-style:preserve-3d; transition:transform 220ms cubic-bezier(.25,.8,.2,1);
           cursor:pointer; background:none; border:none; margin:0; box-shadow: 0 14px 24px rgba(0,0,0,.28), 0 2px 6px rgba(0,0,0,.25); outline:none; }
    .face{ position:absolute; inset:0; border-radius:16px; overflow:hidden; backface-visibility:hidden; border:none; }
    .front{ transform:rotateY(180deg); display:grid; place-items:center; position:relative; }
    .back{ display:grid; place-items:center; background: #0f2d55; }
    .card.flipped{transform:rotateY(180deg)}
    #lenRootWrap { max-width: 500px; margin: 8px auto; background: rgba(255,255,255,0.06); border-radius: 12px; }
    .tarot-actions { max-width: 500px; margin: 8px auto 22px auto; display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }

    /* Banner de espera */
    .waiting-banner{
      background: #d32f2f; color:#fff; font-weight:700; text-align:center;
      padding: 12px 14px; border-radius: 10px; width: fit-content; max-width: 92%;
      box-shadow: 0 2px 8px rgba(0,0,0,.15); user-select: none; pointer-events: none;
    }

    .disabled { opacity: .6; pointer-events: none; }

    @media (min-width: 601px){ .chat-container { border-radius: 12px; } }

    /* ===== ajustes de título ===== */
    body[data-role="cliente"] #roleTitle{ display:none !important; }
    body[data-role="atendente"] #roleTitle{ display:none !important; }

    @keyframes pulseTimer { 0%{transform:scale(1)} 50%{transform:scale(1.06)} 100%{transform:scale(1)} }
    body[data-role="cliente"] .chat-header{ justify-content:center; }
    body[data-role="cliente"] .timer{
      margin-left: 0; font-size: 22px; font-weight: 800; letter-spacing: 1px; padding: 4px 12px; border-radius: 999px;
      border: 2px solid rgba(15,23,42,.12); background: rgba(15,23,42,.06); box-shadow: 0 0 12px rgba(0,0,0,.08), inset 0 0 6px rgba(0,0,0,.04);
      animation: pulseTimer 2s ease-in-out infinite;
    }

    @keyframes ring { 0%{ transform: rotate(0deg); } 5%{ transform: rotate(18deg); } 10%{ transform: rotate(-14deg); } 15%{ transform: rotate(10deg); } 20%{ transform: rotate(-6deg); } 25%{ transform: rotate(4deg); } 30%{ transform: rotate(0deg); } 100%{ transform: rotate(0deg); } }
    body[data-role="cliente"] .btn-som{ transform-origin: top center; animation: ring 1.4s ease-in-out infinite; }

    /* Inverter somente no cliente (mantido), mas .mine/.theirs com !important manda no layout */
    body[data-role="cliente"] .message.client{ justify-content:flex-end; }
    body[data-role="cliente"] .message.attendant{ justify-content:flex-start; }
    body[data-role="cliente"] .message.client .bubble{ background:#d9fdd3; color:#111; border-bottom-right-radius:4px; border-bottom-left-radius:12px; }
    body[data-role="cliente"] .message.attendant .bubble{ background:#fff; color:#222; border-bottom-left-radius:4px; border-bottom-right-radius:12px; }
    @media (max-width: 360px){ .message .bubble{ max-width: 88%; } }

    .only-client{ display: inline-flex; }

    /* Botão mic/enviar */
    #actionBtn{
      width:48px; height:48px; border-radius:50%; display:grid; place-items:center; font-size:20px;
      background:#016e35; color:#fff; border:none; cursor:pointer; transition: transform .06s ease;
    }
    #actionBtn:hover{ transform: translateY(-1px); }
    #actionBtn.mic{ background:#0b7a45; }
    #actionBtn.disabled, #actionBtn:disabled{ opacity:.6; cursor:default; }

    /* ===== REAÇÕES ===== */
    .reactions-row{
      display:flex; gap:6px; align-items:center; margin-top:6px; flex-wrap:wrap;
    }
    .reaction-pill{
      background: rgba(0,0,0,.06); border-radius:12px; padding:2px 8px; font-size:14px; line-height:1.4; user-select:none; cursor:default;
    }
    .react-picker{
      position: fixed; z-index: 9999; background:#fff; border:1px solid #e5e7eb; border-radius:12px; box-shadow: 0 8px 24px rgba(0,0,0,.18);
      padding:6px; display:flex; gap:6px; align-items:center;
    }
    .react-picker button{
      border:none; background:#fff; font-size:20px; line-height:1; padding:6px 8px; border-radius:8px; cursor:pointer;
    }
    .react-picker button:hover{ background:#f3f4f6; }
    .react-picker .reply-opt{
      font-size:14px; padding:6px 10px; background:#eef2ff; border:1px solid #c7d2fe;
    }
  </style>
</head>
<body data-role="">

<!-- Fila -->
<div class="fila-container">
  <div class="fila-info">
    <div class="bolinha" aria-hidden="true"></div>
    <div>Clientes em espera:</div>
    <div class="chip" id="chipEspera">0</div>
  </div>
  <div class="fila-actions">
    <button class="btn-proximo" id="btnProximo">⏭️ Próximo da fila</button>
    <button class="btn-timer" id="btnTimer"><span class="dot"></span> Iniciar tempo</button>
  </div>
</div>

<!-- ===== Chat ===== -->
<div class="chat-container" id="chatBox">
  <div class="chat-header">
    <img id="avatarImg" class="avatar" alt="Foto do atendente" title="Trocar foto" />
    <strong id="roleTitle">Atendimento</strong>
    <div class="timer" id="timer">⏱️ 00:00</div>
    <button id="toggleSound" class="btn-som" title="Ativar/desativar som">🔔</button>
  </div>

  <div class="chat-body" id="chatBody">
    <div class="center-row" id="centerRow">
      <div class="waiting-banner" id="waitingBanner">Consultor em atendimento, aguarde ser chamado...</div>
    </div>
  </div>

  <div class="typing" id="typingHint" style="display:none">Digitando…</div>

  <!-- Barra de resposta -->
  <div class="reply-bar" id="replyBar">
    <div>↩️</div>
    <div class="excerpt" id="replyExcerpt"></div>
    <button class="reply-cancel" id="replyCancel" title="Cancelar resposta">✖</button>
  </div>

  <div class="chat-footer">
    <button id="fileBtn" class="icon-btn secondary" title="Enviar foto/arquivo">📎</button>
    <input type="file" id="fileInput" accept="image/*" hidden />

    <input type="file" id="avatarPicker" accept="image/*" hidden />

    <input type="text" id="msgInput" placeholder="Digite sua mensagem..." />
    <button id="actionBtn" class="mic" title="Gravar áudio">🎤</button>
  </div>

  <button id="endBtn">Encerrar conversa</button>
</div>

<div id="chat-ended">✅ Conversa encerrada</div>

<!-- ===== Tarot ===== -->
<div id="lenRootWrap">
  <div id="lenRoot">
    <div class="layout">
      <main class="board" id="board" aria-label="Mesa de cartas"></main>
    </div>
  </div>
</div>
<div class="tarot-actions">
  <button class="btn-print" id="btnTarotPrint" aria-label="Enviar print das cartas">Enviar print das cartas</button>
  <button class="btn-shuffle" id="btnTarotShuffle" aria-label="Embaralhar cartas">Embaralhar cartas</button>
</div>

<!-- Áudio -->
<audio id="sndSend" preload="auto" src="/sounds/notify.mp3"></audio>
<audio id="sndRecv" preload="auto" src="/sounds/notify.mp3"></audio>
<audio id="sndQueue" preload="auto" src="/sounds/bell.mp3"></audio>

<!-- libs -->
<script src="/socket.io/socket.io.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<script>
/* ===== Ajuste 100vh móvel ===== */
function setVh(){ const vh = window.innerHeight * 0.01; document.documentElement.style.setProperty('--vh', `${vh}px`); }
setVh(); addEventListener('resize', setVh); addEventListener('orientationchange', setVh);

/* ===== IDENTIDADE POR ABA ===== */
const qs = new URLSearchParams(location.search);
const ROLE = (qs.get("role") || "cliente").toLowerCase();
const ROOM = (qs.get("room") || "main");
function genUID(){ if (crypto && crypto.randomUUID) return crypto.randomUUID(); return Date.now()+"-"+Math.random().toString(36).slice(2); }
if (!sessionStorage.getItem("UID")) sessionStorage.setItem("UID", genUID());
const UID = sessionStorage.getItem("UID");
document.body.setAttribute("data-role", ROLE);

/* ===== Título ===== */
const rtEl = document.getElementById("roleTitle");
if (ROLE === "atendente"){ rtEl.textContent = ""; } else { rtEl.textContent = `Atendimento (Cliente) — sala: ${ROOM}`; }

/* ===== AVATAR ===== */
const DEFAULT_AVATAR = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="128" height="128" viewBox="0 0 96 96"><circle cx="48" cy="32" r="16" fill="%23cccccc"/><rect x="16" y="56" width="64" height="28" rx="14" fill="%23cccccc"/></svg>';
const AVATAR_KEY = `avatar:${ROOM}`;
const REMOTE_AVATAR_KEY = `remoteAvatar:${ROOM}`;
const avatarImg = document.getElementById('avatarImg');
const avatarPicker = document.getElementById('avatarPicker');

function setLocalAvatar(dataUrl){ try{ sessionStorage.setItem(AVATAR_KEY, dataUrl); }catch(_){} avatarImg.src = dataUrl; }
function setRemoteAvatar(dataUrl){ try{ sessionStorage.setItem(REMOTE_AVATAR_KEY, dataUrl); }catch(_){} avatarImg.src = dataUrl; }
function initAvatar(){
  avatarImg.src = DEFAULT_AVATAR;
  if (ROLE === 'atendente'){
    const saved = sessionStorage.getItem(AVATAR_KEY);
    if (saved) avatarImg.src = saved;
    avatarImg.addEventListener('click', ()=> avatarPicker.click());
    avatarPicker.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      if (!f.type.startsWith('image/')) return;
      const reader = new FileReader();
      reader.onload = async ()=>{
        const dataUrl = await downscaleDataUrl(reader.result, 256);
        setLocalAvatar(dataUrl);
        if (isPaired) { try { socket.emit("chat_image", { dataUrl, alt: "__avatar__" }); } catch(_){} }
        avatarPicker.value = '';
      };
      reader.readAsDataURL(f);
    });
  } else {
    const remote = sessionStorage.getItem(REMOTE_AVATAR_KEY);
    if (remote) avatarImg.src = remote;
  }
}

/* ===== HISTÓRICO LOCAL ===== */
const STORE_KEY = `history:${ROOM}:${ROLE}:${UID}`;
let history = []; let restored = false;
function saveHistory(){ try{ sessionStorage.setItem(STORE_KEY, JSON.stringify(history.slice(-200))); }catch(_){} }
function restoreHistory(){
  try { history = JSON.parse(sessionStorage.getItem(STORE_KEY) || "[]"); } catch{ history = []; }
  history.forEach(h=>{
    if (h.t==="text") addMessage(h.text, h.sender, h.id, h.seen, h.reply || null);
    if (h.t==="img") addImageMessage(h.dataUrl, h.sender, h.alt||"Imagem", h.id, h.seen, h.reply || null);
    if (h.t==="aud") addAudioMessage(h.dataUrl, h.sender, h.dur||0, h.id, h.seen, h.reply || null);
  });
  restored = true;
}

/* ===== DOM ===== */
const chatBody = document.getElementById('chatBody');
const centerRow = document.getElementById('centerRow');
const waitingBanner = document.getElementById('waitingBanner');
const timerEl = document.getElementById('timer');
const msgInput = document.getElementById('msgInput');
const actionBtn = document.getElementById('actionBtn');
let segundos = 0, cronometro = null, isPaired = false;

/* ===== REPLY ===== */
let replyContext = null;
const replyBar = document.getElementById('replyBar');
const replyExcerpt = document.getElementById('replyExcerpt');
const replyCancel = document.getElementById('replyCancel');
replyCancel.addEventListener('click', clearReply);
function setReply(ctx){
  replyContext = ctx; // {id, preview}
  replyExcerpt.textContent = ctx.preview || '';
  replyBar.style.display = 'flex';
}
function clearReply(){
  replyContext = null;
  replyBar.style.display = 'none';
  replyExcerpt.textContent = '';
}

/* ===== Persistência local do timer ===== */
const TIMER_KEY = `timer:${ROOM}`;
function saveTimerLocal(state){ try{ localStorage.setItem(TIMER_KEY, JSON.stringify(state)); }catch(_){} }
function loadTimerLocal(){ try{ return JSON.parse(localStorage.getItem(TIMER_KEY) || "{}"); }catch(_){ return {}; } }
function applyTimerLocalOnLoad(){
  const st = loadTimerLocal();
  if (Number.isFinite(st.pausedSec)){
    segundos = Math.max(0, st.pausedSec|0);
    updateTimer();
  } else {
    segundos = 0; updateTimer();
  }
}

/* ===== SOCKET ===== */
const socket = io({ transports: ["websocket", "polling"] });

socket.on("connect", () => {
  socket.emit("register", { role: ROLE, room: ROOM, name: ROLE === "cliente" ? "Cliente" : "Atendente", uid: UID });

  initAvatar();

  if (ROLE === "cliente") { centerRow.style.display = "flex"; setChatEnabled(false); }
  if (!restored) restoreHistory();

  applyTimerLocalOnLoad();

  requestAnimationFrame(scrollDown);
  updateActionBtnState();
});

socket.on("queue_size", ({ size }) => {
  const chip = document.getElementById("chipEspera"); if (chip) chip.textContent = String(size);
});

socket.on("queue_join", () => { if (ROLE === "atendente") playSound("sndQueue"); });

socket.on("paired", () => {
  isPaired = true;
  avatarImg.classList.add('online');
  timerEl.classList.toggle('running', !!cronometro);
  centerRow.style.display = "none";
  setChatEnabled(true);
  if (ROLE === "cliente" && history.length === 0) {
    addMessage("Conectado ao atendente.", "client", genUID(), true);
    history.push({ t:"text", sender:"client", text:"Conectado ao atendente.", id: genUID(), seen: true }); saveHistory();
  }
  if (ROLE === 'atendente'){
    const av = sessionStorage.getItem(AVATAR_KEY);
    if (av) { try { socket.emit("chat_image", { dataUrl: av, alt: "__avatar__" }); } catch(_){} }
  }
  scrollDown();
  updateActionBtnState();
});

/* ===== Helpers de exclusão ===== */
function addDeleteButton(container, id){
  // Mantido por compatibilidade; não usamos mais aqui.
  if (!id) return;
  const btn = document.createElement('button');
  btn.className = 'del-btn';
  btn.title = 'Apagar mensagem';
  btn.textContent = '🗑️';
  btn.style.cssText = 'margin-left:6px;background:transparent;border:none;cursor:pointer;opacity:.7;';
  btn.addEventListener('click', ()=>{
    removeMessageDom(id);
    removeFromHistory(id);
    try{ socket.emit("delete_message", { id }); }catch(_){}
  });
  return btn;
}
function removeMessageDom(id){
  const el = chatBody.querySelector(`.message[data-id="${id}"]`);
  if (el) el.remove();
}
function removeFromHistory(id){
  const idx = history.findIndex(h => h.id === id);
  if (idx >= 0){ history.splice(idx,1); saveHistory(); }
}

/* ===== REAÇÕES (estado + helpers) ===== */
const REACT_KEY = `reactions:${ROOM}`;
let reactionsMap = {}; // { msgId: { "👍": [uid1,uid2], "❤️":[uid3] } }

function loadReactions(){
  try { reactionsMap = JSON.parse(sessionStorage.getItem(REACT_KEY) || "{}"); } catch { reactionsMap = {}; }
}
function saveReactions(){
  try { sessionStorage.setItem(REACT_KEY, JSON.stringify(reactionsMap)); } catch {}
}
loadReactions();

const EMOJIS = ["👍","❤️","😂","😮","😢","🙏"];

function toggleReactionLocal(msgId, emoji, uid){
  if (!reactionsMap[msgId]) reactionsMap[msgId] = {};
  if (!reactionsMap[msgId][emoji]) reactionsMap[msgId][emoji] = [];
  const arr = reactionsMap[msgId][emoji];
  const i = arr.indexOf(uid);
  if (i >= 0) arr.splice(i,1); else arr.push(uid);
  if (reactionsMap[msgId][emoji].length === 0) delete reactionsMap[msgId][emoji];
  if (Object.keys(reactionsMap[msgId]).length === 0) delete reactionsMap[msgId];
  saveReactions();
}

function renderReactionsRow(container, msgId){
  let row = container.querySelector('.reactions-row');
  if (!reactionsMap[msgId]) { if (row) row.remove(); return; }
  const entries = Object.entries(reactionsMap[msgId]).filter(([,uids])=>uids.length>0);
  if (entries.length === 0){ if (row) row.remove(); return; }
  if (!row){
    row = document.createElement('div');
    row.className = 'reactions-row';
    container.appendChild(row);
  }
  row.innerHTML = "";
  entries.forEach(([emo,uids])=>{
    const pill = document.createElement('span');
    pill.className = 'reaction-pill';
    pill.textContent = `${emo} ${uids.length}`;
    row.appendChild(pill);
  });
}

function openReactPicker(x, y, onPick){
  closeReactPicker();
  const picker = document.createElement('div');
  picker.className = 'react-picker';
  EMOJIS.forEach(e=>{
    const b=document.createElement('button'); b.type='button'; b.textContent=e;
    b.addEventListener('click', ()=>{ onPick(e); closeReactPicker(); });
    picker.appendChild(b);
  });
  const sep = document.createElement('span'); sep.style.marginLeft='6px'; picker.appendChild(sep);
  const replyBtn = document.createElement('button'); replyBtn.type='button'; replyBtn.textContent='↩️ Responder'; replyBtn.className='reply-opt';
  replyBtn.addEventListener('click', ()=>{ onPick('__reply__'); closeReactPicker(); });
  picker.appendChild(replyBtn);

  document.body.appendChild(picker);
  const rect = picker.getBoundingClientRect();
  picker.style.left = Math.max(6, Math.min(x - rect.width/2, window.innerWidth - rect.width - 6)) + 'px';
  picker.style.top  = Math.max(6, Math.min(y - rect.height - 8, window.innerHeight - rect.height - 6)) + 'px';

  setTimeout(()=>{
    const off = (e)=>{ if (!picker.contains(e.target)) closeReactPicker(); };
    document.addEventListener('pointerdown', off, { once:true });
  }, 0);
}
function closeReactPicker(){
  const el = document.querySelector('.react-picker'); if (el) el.remove();
}

/* long press util */
function addLongPress(el, cb, ms=450){
  let t=null;
  const start=(e)=>{ t=setTimeout(()=>cb(e), ms); };
  const cancel=()=>{ if(t){clearTimeout(t); t=null;} };
  el.addEventListener('pointerdown', start);
  el.addEventListener('pointerup', cancel);
  el.addEventListener('pointercancel', cancel);
  el.addEventListener('pointerleave', cancel);
}

/* ===== Helpers: lixeira no balão, swipe reply e long-press no balão ===== */
function attachTapTrash(bubbleEl, msgId, isMine){
  if (!isMine) return; // lixeira apenas no próprio balão
  let trash = bubbleEl.querySelector('.trash-pop');
  if (!trash){
    trash = document.createElement('button');
    trash.className = 'trash-pop';
    trash.type = 'button';
    trash.title = 'Apagar mensagem';
    trash.textContent = '🗑️';
    trash.addEventListener('click', (e)=>{
      e.stopPropagation();
      removeMessageDom(msgId);
      removeFromHistory(msgId);
      try{ socket.emit("delete_message", { id: msgId }); }catch(_){}
    });
    bubbleEl.appendChild(trash);
  }
  bubbleEl.addEventListener('click', (e)=>{
    if (e.target.closest('audio') || e.target.closest('button')) return;
    bubbleEl.classList.toggle('show-trash');
    const off = (ev)=>{
      if (!bubbleEl.contains(ev.target)){
        bubbleEl.classList.remove('show-trash');
        document.removeEventListener('pointerdown', off, true);
      }
    };
    document.addEventListener('pointerdown', off, true);
  });
}

function attachSwipeToReply(bubbleEl, msgId){
  let startX=0, startY=0, dx=0, dy=0, dragging=false, activated=false, pointerId=null;
  const THRESH = 52;     // distância para disparar reply
  const MAX_ANGLE = 28;  // tolerância vertical

  const getPreview = ()=>{
    const t = bubbleEl.querySelector('.text');
    const img = bubbleEl.querySelector('.image img');
    const aud = bubbleEl.querySelector('audio');
    if (t) return t.textContent.trim().slice(0,120);
    if (img) return '🖼️ ' + (img.alt || 'Imagem');
    if (aud) return '🎤 Áudio';
    return '';
  };

  const onDown = (e)=>{
    if (e.target.closest('button') || e.target.closest('audio')) return;
    dragging = true; activated = false; dx = dy = 0;
    startX = e.clientX; startY = e.clientY;
    pointerId = e.pointerId;
    try{ bubbleEl.setPointerCapture(pointerId); }catch(_){}
    if (e.pointerType === 'touch') { try{ e.preventDefault(); }catch(_){} }
    bubbleEl.classList.add('dragging','swipe-hint');
  };

  const onMove = (e)=>{
    if (!dragging) return;
    dx = e.clientX - startX; dy = e.clientY - startY;
    if (dx < 0) dx = 0; // só direita
    const angle = Math.abs(Math.atan2(dy, dx) * 180/Math.PI);
    if (dx > 0 && angle < MAX_ANGLE){
      bubbleEl.style.transform = `translateX(${Math.min(dx, THRESH)}px)`;
      if (dx >= THRESH && !activated){
        activated = true;
        if (navigator.vibrate) try{ navigator.vibrate(8); }catch(_){}
      }
    }
  };

  const onUp = ()=>{
    if (!dragging) return;
    dragging = false;
    try{ bubbleEl.releasePointerCapture(pointerId); }catch(_){}
    pointerId = null;
    bubbleEl.classList.remove('dragging','swipe-hint');
    bubbleEl.style.transform = '';
    if (activated){
      const preview = getPreview();
      if (preview){
        setReply({ id: msgId, preview });
        msgInput.focus();
      }
    }
  };

  bubbleEl.addEventListener('pointerdown', onDown, { passive:false });
  bubbleEl.addEventListener('pointermove', onMove,  { passive:true  });
  bubbleEl.addEventListener('pointerup',   onUp);
  bubbleEl.addEventListener('pointercancel', onUp);
}

function attachLongPressOnBubble(bubbleEl, id){
  addLongPress(bubbleEl, (e)=>{
    const { clientX:x, clientY:y } = e;
    openReactPicker(x,y,(choice)=>{
      if (choice==='__reply__'){
        const preview =
          (bubbleEl.querySelector('.text')?.textContent?.trim()) ||
          (bubbleEl.querySelector('.image img') ? '🖼️ Imagem' : '') ||
          (bubbleEl.querySelector('audio') ? '🎤 Áudio' : '');
        if (preview){ setReply({ id, preview: preview.slice(0,120) }); msgInput.focus(); }
      } else {
        toggleReactionLocal(id, choice, UID);
        renderReactionsRow(bubbleEl, id);
        try{ socket.emit("message_reaction", { id, emoji: choice, uid: UID }); }catch(_){}
      }
    });
  }, 450);
}

/* LONG PRESS no áudio para reações (mantido) */
function attachLongPressAudio(targetWrap, id){
  addLongPress(targetWrap, (e)=>{
    const { clientX:x, clientY:y } = e;
    openReactPicker(x,y,(choice)=>{
      if (choice==='__reply__'){
        setReply({ id, preview: '🎤 Áudio' });
      } else {
        toggleReactionLocal(id, choice, UID);
        renderReactionsRow(targetWrap.parentElement, id);
        try{ socket.emit("message_reaction", { id, emoji: choice, uid: UID }); }catch(_){}
      }
    });
  });
}

/* ====== MENSAGENS ====== */
const mySide = (ROLE === "atendente") ? "attendant" : "client";

function makeReplyNode(reply){
  if (!reply) return null;
  const q = document.createElement('div');
  q.className = 'reply-quote';
  q.textContent = reply.preview || '';
  return q;
}

function addMessage(text, sender, id = genUID(), seen = false, reply=null){
  const d = document.createElement('div');
  d.classList.add('message', sender);
  d.dataset.id = id;
  const isMine = (sender === mySide);
  d.classList.add(isMine ? 'mine' : 'theirs');

  const bubble = document.createElement('div');
  bubble.className = 'bubble';

  const q = makeReplyNode(reply); if (q) bubble.appendChild(q);

  const t = document.createElement('div'); t.classList.add('text'); t.textContent = text;
  bubble.appendChild(t);

  // NOVO: lixeira no balão (apenas minhas) + swipe reply + long-press bubble
  attachTapTrash(bubble, id, isMine);
  attachSwipeToReply(bubble, id);
  attachLongPressOnBubble(bubble, id);

  d.appendChild(bubble);

  if (isMine){
    const meta = document.createElement('div'); meta.className = 'meta';
    const rc = document.createElement('span'); rc.className = 'receipt' + (seen ? ' seen' : ''); rc.id = `rcp-${id}`;
    rc.innerHTML = '<span class="check">✓</span><span class="check">✓</span>';
    meta.appendChild(rc);
    d.appendChild(meta);
  }
  chatBody.appendChild(d);
  renderReactionsRow(bubble, id);
  scrollDown();
}

function addImageMessage(dataUrl, sender, alt="Imagem", id = genUID(), seen=false, reply=null){
  const d = document.createElement('div'); d.classList.add('message', sender); d.dataset.id = id;
  const isMine = (sender === mySide);
  d.classList.add(isMine ? 'mine' : 'theirs');

  const bubble = document.createElement('div');
  bubble.className = 'bubble';

  const q = makeReplyNode(reply); if (q) bubble.appendChild(q);

  const w = document.createElement('div'); w.classList.add('image');
  const i = document.createElement('img'); i.src = dataUrl; i.alt = alt;
  w.appendChild(i); bubble.appendChild(w);

  // NOVO
  attachTapTrash(bubble, id, isMine);
  attachSwipeToReply(bubble, id);
  attachLongPressOnBubble(bubble, id);

  d.appendChild(bubble);

  if (isMine){
    const meta = document.createElement('div'); meta.className = 'meta';
    const rc = document.createElement('span'); rc.className = 'receipt' + (seen ? ' seen' : ''); rc.id = `rcp-${id}`;
    rc.innerHTML = '<span class="check">✓</span><span class="check">✓</span>';
    meta.appendChild(rc);
    d.appendChild(meta);
  }
  chatBody.appendChild(d);
  renderReactionsRow(bubble, id);
  scrollDown();
}

function addAudioMessage(dataUrl, sender, durSec=0, id = genUID(), seen=false, reply=null){
  const d = document.createElement('div'); d.classList.add('message', sender); d.dataset.id = id;
  const isMine = (sender === mySide);
  d.classList.add(isMine ? 'mine' : 'theirs');

  const bubble = document.createElement('div');
  bubble.className = 'bubble';

  const q = makeReplyNode(reply); if (q) bubble.appendChild(q);

  const wrap = document.createElement('div'); wrap.classList.add('audio-wrap');

  const audio = document.createElement('audio'); 
  audio.controls = true; 
  audio.preload = "metadata"; 
  audio.src = dataUrl; 
  wrap.appendChild(audio);

  /* Barra de controles extra: ⏪ 5s */
  const tools = document.createElement('div'); 
  tools.className = 'audio-toolbar';
  const backBtn = document.createElement('button');
  backBtn.className = 'rewind-btn';
  backBtn.type = 'button';
  backBtn.textContent = '⏪ 5s';
  backBtn.title = 'Voltar 5 segundos';
  backBtn.addEventListener('click', async (e)=>{
    e.stopPropagation();
    if (audio.readyState < 1) await new Promise(r=> audio.addEventListener('loadedmetadata', r, { once:true }));
    try{ audio.currentTime = Math.max(0, audio.currentTime - 5); }catch(_){}
  });
  tools.appendChild(backBtn);
  wrap.appendChild(tools);

  const dur = document.createElement('div'); dur.className = 'duration';
  dur.textContent = durSec ? `⏱️ ${String(Math.floor(durSec/60)).padStart(2,'0')}:${String(Math.floor(durSec%60)).padStart(2,'0')}` : 'Áudio';
  wrap.appendChild(dur); 

  wrap.addEventListener('click', (e)=>{
    if (e.target.closest('button')) return;
    if (audio.paused) { audio.play().catch(()=>{}); } else { audio.pause(); }
  });

  bubble.appendChild(wrap);

  /* LONG PRESS no áudio para reações */
  attachLongPressAudio(wrap, id);

  // NOVO
  attachTapTrash(bubble, id, isMine);
  attachSwipeToReply(bubble, id);
  attachLongPressOnBubble(bubble, id);

  d.appendChild(bubble);

  if (isMine){
    const meta = document.createElement('div'); meta.className = 'meta';
    const rc = document.createElement('span'); rc.className = 'receipt' + (seen ? ' seen' : ''); rc.id = `rcp-${id}`;
    rc.innerHTML = '<span class="check">✓</span><span class="check">✓</span>';
    meta.appendChild(rc);
    d.appendChild(meta);
  }
  chatBody.appendChild(d);
  renderReactionsRow(bubble, id);
  scrollDown();
  if (!isMine){ audio.play().catch(()=>{}); }
}

function markSeen(id){
  const r = document.getElementById(`rcp-${id}`); if (r) r.classList.add('seen');
  const idx = history.findIndex(h => h.id === id);
  if (idx >= 0) { history[idx].seen = true; saveHistory(); }
}

/* ===== Recebimento ===== */
function shouldIgnoreInbound(){
  return (ROLE === "cliente" && !isPaired);
}

socket.on("chat_message", ({ from, text, id, reply }) => {
  if (shouldIgnoreInbound()) return;
  const s = from === "attendant" ? "attendant" : "client";
  addMessage(text, s, id, false, reply || null);
  history.push({ t:"text", sender:s, text, id, seen:false, reply: reply || null }); saveHistory();
  if (mySide !== s) {
    playSound("sndRecv");
    if (document.visibilityState === 'visible') { try { socket.emit("message_seen", { id }); } catch(_){} }
  }
});

socket.on("message_seen", ({ id }) => markSeen(id));

socket.on("chat_image", ({ from, dataUrl, alt, id, reply }) => {
  if (shouldIgnoreInbound()) return;
  if (alt === "__avatar__") { setRemoteAvatar(dataUrl); return; }
  const s = from === "attendant" ? "attendant" : "client";
  const mid = id || genUID();
  addImageMessage(dataUrl, s, alt || "Imagem", mid, false, reply || null);
  history.push({ t:"img", sender:s, dataUrl, alt, id: mid, seen:false, reply: reply || null }); saveHistory();
  if (mySide !== s) playSound("sndRecv");
});

socket.on("chat_audio", ({ from, dataUrl, durSec=0, id, reply }) => {
  if (shouldIgnoreInbound()) return;
  const s = from === "attendant" ? "attendant" : "client";
  const mid = id || genUID();
  addAudioMessage(dataUrl, s, durSec, mid, false, reply || null);
  history.push({ t:"aud", sender:s, dataUrl, dur: durSec, id: mid, seen:false, reply: reply || null }); saveHistory();
  if (mySide !== s) playSound("sndRecv");
});

/* ===== Reações recebidas ===== */
socket.on("message_reaction", ({ id, emoji, uid })=>{
  if (shouldIgnoreInbound()) return;
  const msg = chatBody.querySelector(`.message[data-id="${id}"] .bubble`);
  if (!msg) return;
  toggleReactionLocal(id, emoji, uid);
  renderReactionsRow(msg, id);
});

/* ===== Deleção recebida ===== */
socket.on("delete_message", ({ id }) => {
  if (shouldIgnoreInbound()) return;
  if (!id) return;
  removeMessageDom(id);
  removeFromHistory(id);
  if (reactionsMap[id]) { delete reactionsMap[id]; saveReactions(); }
});

/* ===== Digitando ===== */
const typingHint = document.getElementById("typingHint");
msgInput.addEventListener("input", ()=>{
  if (ROLE === "cliente" && !isPaired) return;
  updateActionBtnState();
  socket.emit("typing", { isTyping: msgInput.value.trim().length > 0 });
});
msgInput.addEventListener("keydown", (e)=>{
  if (e.key === "Enter"){
    e.preventDefault();
    if (msgInput.value.trim()) sendMessage();
  }
});
socket.on("typing", ({ from, isTyping }) => {
  if (shouldIgnoreInbound()) return;
  const show = ((from === "attendant" && ROLE === "cliente") || (from === "client" && ROLE === "atendente")) && isTyping;
  typingHint.style.display = show ? "block" : "none";
  scrollDown();
});

/* ===== Timer / Encerrar ===== */
socket.on("timer_state", ({ running, elapsedSec }) => {
  if (shouldIgnoreInbound()) return;
  segundos = elapsedSec || 0;
  if (running){
    saveTimerLocal({ running:true, startTs: Date.now() - (segundos*1000), pausedSec:0 });
    iniciarCronometro(true);
  } else {
    pararCronometro(true);
    saveTimerLocal({ running:false, startTs:0, pausedSec:segundos });
  }
  updateTimer();
});

socket.on("conversation_ended", ({ reason }) => {
  clearInterval(cronometro); cronometro = null; segundos = 0; updateTimer();
  timerEl.classList.remove('running');
  avatarImg.classList.remove('online');
  try{ localStorage.removeItem(TIMER_KEY); }catch(_){}
  showEnded(reason); clearHistory(); chatBody.innerHTML = "";
  try { socket.emit("queue_sync", { room: ROOM }); } catch(_){ }

  if (ROLE === "cliente") {
    const END_URL = "https://atendimento2.onrender.com/encerrado.html?v=" + Date.now();
    const box = document.createElement('div');
    box.style.cssText = "text-align:center;padding:12px;";
    box.innerHTML = `🔁 Redirecionando para a avaliação…
      <br><a href="${END_URL}" style="font-weight:700;" target="_top" rel="noopener">Ir agora</a>`;
    document.body.appendChild(box);

    setTimeout(() => {
      try { window.location.replace(END_URL); }
      catch(_) { window.location.href = END_URL; }
    }, 800);
  }
});

/* ===== UI helpers ===== */
function updateTimer(){
  const m = String(Math.floor(segundos/60)).padStart(2,'0');
  const s = String(segundos%60).padStart(2,'0');
  timerEl.textContent = `⏱️ ${m}:${s}`;
}
function iniciarCronometro(silent){
  if (!cronometro) {
    const startTs = Date.now() - (segundos*1000);
    saveTimerLocal({ running:true, startTs, pausedSec:0 });
    cronometro = setInterval(()=>{ segundos++; updateTimer(); }, 1000);
    timerEl.classList.add('running');
    if (!silent) socket.emit("timer_start");
  }
}
function pararCronometro(silent){
  clearInterval(cronometro); cronometro = null;
  saveTimerLocal({ running:false, startTs:0, pausedSec:segundos });
  timerEl.classList.remove('running');
  if (!silent) socket.emit("timer_stop");
}
function scrollDown(){
  chatBody.scrollTop = chatBody.scrollHeight;
}

function setChatEnabled(enabled){
  const input = document.getElementById('msgInput');
  if (enabled){
    input.removeAttribute('disabled');
    actionBtn.disabled = false; actionBtn.classList.remove('disabled');
  } else {
    input.setAttribute('disabled','disabled');
    actionBtn.disabled = true; actionBtn.classList.add('disabled');
  }
  updateActionBtnState();
}

function showEnded(reason){
  const ended = document.getElementById("chat-ended");
  ended.textContent = reason==="attendant_left"?"⚠️ Atendente desconectou":(reason==="client_left"?"⚠️ Cliente desconectou":"✅ Conversa encerrada");
  ended.style.display = "block";
  setTimeout(()=>{ ended.style.display = "none"; }, 1500);
}

function clearHistory(){ try{ sessionStorage.removeItem(STORE_KEY); }catch(_){} history = []; }

/* ===== Sons ===== */
let soundEnabled = true, audioReady = false;
function unlockAudioOnce(){ if (audioReady) return; const tryUnlock = (id)=>{ const a=document.getElementById(id); if(!a) return; a.muted=true; a.play().then(()=>{ a.pause(); a.currentTime=0; a.muted=false; a.volume=1; audioReady=true; }).catch(()=>{}); }; tryUnlock("sndSend"); tryUnlock("sndRecv"); tryUnlock("sndQueue"); }
window.addEventListener("pointerdown", unlockAudioOnce, { once: true });
function playSound(id){ if (!soundEnabled) return; const a=document.getElementById(id); if(a){ try{ a.currentTime=0; a.play(); }catch(_){} } }
const toggleBtn = document.getElementById("toggleSound"); if (toggleBtn){ toggleBtn.addEventListener("click", ()=>{ soundEnabled = !soundEnabled; toggleBtn.classList.toggle("off", !soundEnabled); toggleBtn.textContent = soundEnabled ? "🔔" : "🔕"; unlockAudioOnce(); }); }

/* ===== Envio (inclui reply) ===== */
function sendMessage(){
  if (ROLE === "cliente" && !isPaired) return;
  const msg = msgInput.value.trim(); if (!msg) return;
  const id = genUID();
  const reply = replyContext ? { id: replyContext.id, preview: replyContext.preview } : null;
  addMessage(msg, mySide, id, false, reply);
  history.push({ t:"text", sender: mySide, text: msg, id, seen:false, reply }); saveHistory();
  socket.emit("chat_message", { text: msg, id, reply });
  playSound("sndSend");
  msgInput.value = "";
  clearReply();
  updateActionBtnState();
  scrollDown();
}

/* ===== Ação do botão (mic ↔ enviar) ===== */
actionBtn.addEventListener('pointerdown', unlockAudioOnce, { once: true });
actionBtn.addEventListener('click', ()=>{
  if (ROLE === "cliente" && !isPaired) return;
  const hasText = msgInput.value.trim().length > 0;
  if (isRecording()){ stopRecording(); return; }
  if (hasText) sendMessage(); else startRecording();
});

/* ===== Imagem ===== */
const fileBtn = document.getElementById('fileBtn');
const fileInput = document.getElementById('fileInput');
if (fileBtn && fileInput){
  fileBtn.addEventListener('click', ()=>{ if (ROLE === "cliente" && !isPaired) return; fileInput.click(); });
  fileInput.addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    if (!f.type.startsWith('image/')){ addMessage("Apenas imagens são suportadas aqui.", mySide); return; }
    const reader = new FileReader();
    reader.onload = async () => {
      const dataUrl = await downscaleDataUrl(reader.result, 960);
      const id = genUID();
      const reply = replyContext ? { id: replyContext.id, preview: replyContext.preview } : null;
      addImageMessage(dataUrl, mySide, f.name || "Imagem", id, false, reply);
      history.push({ t:"img", sender: mySide, dataUrl, alt: f.name||"Imagem", id, seen:false, reply }); saveHistory();
      socket.emit("chat_image", { dataUrl, alt: f.name||"Imagem", id, reply });
      playSound("sndSend");
      fileInput.value = "";
      clearReply();
    };
    reader.readAsDataURL(f);
  });
}

/* ===== ÁUDIO: gravação ===== */
let mediaRecorder = null, recChunks = [], recStartTs = 0, recStopTimer = null, activeStream = null;
let wavRecorder = null;

function pickBestAudioMime(){
  const tries = [
    'audio/mp4;codecs=mp4a.40.2',
    'audio/mp4',
    'audio/webm;codecs=opus',
    'audio/ogg;codecs=opus',
    'audio/webm',
    'audio/ogg'
  ];
  if (!window.MediaRecorder || !MediaRecorder.isTypeSupported) return '';
  return tries.find(t => MediaRecorder.isTypeSupported(t)) || '';
}

function isRecording(){
  return (mediaRecorder && mediaRecorder.state === 'recording') || (wavRecorder && wavRecorder.recording);
}

async function startRecording(){
  if (ROLE === "cliente" && !isPaired) return;
  try{
    const constraints = { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true, channelCount: 1 } };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    activeStream = stream;

    const useMR = !!window.MediaRecorder;
    const mime = pickBestAudioMime();

    if (useMR) {
      try {
        mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined);
        recChunks = []; recStartTs = Date.now();
        mediaRecorder.ondataavailable = (ev)=>{ if (ev.data && ev.data.size) recChunks.push(ev.data); };
        mediaRecorder.onstop = onMediaRecorderStop;
        mediaRecorder.start(200);
      } catch (err) {
        await startWavFallback(stream);
      }
    } else {
      await startWavFallback(stream);
    }

    actionBtn.classList.add('rec','on');
    updateActionBtnState();
    recStopTimer = setTimeout(()=>{ if (isRecording()) stopRecording(); }, 60000);
  }catch(err){
    console.error(err);
    addMessage("Permita acesso ao microfone para enviar áudio.", mySide);
  }
}

function stopRecording(){
  try{
    if (mediaRecorder && mediaRecorder.state === 'recording'){
      mediaRecorder.stop();
    } else if (wavRecorder && wavRecorder.recording){
      wavRecorder.stop().then(({ blob, durSec }) => handleAudioBlob(blob, durSec));
    }
  }catch(_){}
}

function onMediaRecorderStop(){
  clearTimeout(recStopTimer); recStopTimer = null;
  const durSec = Math.max(1, Math.round((Date.now()-recStartTs)/1000));
  const blobType = (mediaRecorder && mediaRecorder.mimeType) ? mediaRecorder.mimeType : (recChunks[0] && recChunks[0].type) || 'audio/mp4';
  const blob = new Blob(recChunks, { type: blobType });
  handleAudioBlob(blob, durSec);
}

function handleAudioBlob(blob, durSec){
  const fr = new FileReader();
  fr.onload = ()=>{
    const dataUrl = fr.result;
    const id = genUID();
    const reply = replyContext ? { id: replyContext.id, preview: replyContext.preview } : null;
    addAudioMessage(dataUrl, mySide, durSec, id, false, reply);
    history.push({ t:"aud", sender: mySide, dataUrl, dur: durSec, id, seen:false, reply }); saveHistory();
    socket.emit("chat_audio", { dataUrl, durSec, id, reply });
    playSound("sndSend");
    clearReply();
  };
  fr.readAsDataURL(blob);

  if (activeStream){ try{ activeStream.getTracks().forEach(t=>t.stop()); }catch(_){} }
  activeStream = null;
  mediaRecorder = null;
  wavRecorder = null;
  actionBtn.classList.remove('rec','on');
  updateActionBtnState();
}

/* ===== Fallback WAV ===== */
async function startWavFallback(stream){
  wavRecorder = new WavFallbackRecorder(stream);
  await wavRecorder.start();
}

class WavFallbackRecorder{
  constructor(stream){
    this.stream = stream;
    this.ctx = null;
    this.source = null;
    this.processor = null;
    this.buffers = [];
    this.recording = false;
    this.startTs = 0;
  }
  async start(){
    const AC = window.AudioContext || window.webkitAudioContext;
    this.ctx = new AC();
    this.source = this.ctx.createMediaStreamSource(this.stream);
    const bufferSize = 4096;
    this.processor = this.ctx.createScriptProcessor(bufferSize, 1, 1);
    this.source.connect(this.processor);
    this.processor.connect(this.ctx.destination);
    this.processor.onaudioprocess = (e)=>{
      if (!this.recording) return;
      const ch0 = e.inputBuffer.getChannelData(0);
      this.buffers.push(new Float32Array(ch0));
    };
    this.recording = true;
    this.startTs = Date.now();
  }
  async stop(){
    this.recording = false;
    try{ this.processor.disconnect(); }catch(_){}
    try{ this.source.disconnect(); }catch(_){}
    try{ await this.ctx.close(); }catch(_){}
    try{ this.stream.getTracks().forEach(t=>t.stop()); }catch(_){}

    const len = this.buffers.reduce((a,b)=>a + b.length, 0);
    const data = new Float32Array(len);
    let off = 0;
    for (const b of this.buffers){ data.set(b, off); off += b.length; }
    const wavBlob = floatToWavBlob(data, 1, 44100);
    const durSec = Math.max(1, Math.round((Date.now()-this.startTs)/1000));
    return { blob: wavBlob, durSec };
  }
}

function floatToWavBlob(float32, numChannels, sampleRate){
  const bytesPerSample = 2;
  const blockAlign = numChannels * bytesPerSample;
  const buffer = new ArrayBuffer(44 + float32.length * bytesPerSample);
  const view = new DataView(buffer);

  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + float32.length * bytesPerSample, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, 8 * bytesPerSample, true);
  writeString(view, 36, 'data');
  view.setUint32(40, float32.length * bytesPerSample, true);

  let offset = 44;
  for (let i = 0; i < float32.length; i++){
    let s = Math.max(-1, Math.min(1, float32[i]));
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    offset += 2;
  }
  return new Blob([view], { type: 'audio/wav' });
}
function writeString(view, offset, str){
  for (let i = 0; i < str.length; i++){
    view.setUint8(offset + i, str.charCodeAt(i));
  }
}

/* ===== Utils ===== */
function updateActionBtnState(){
  const hasText = msgInput.value.trim().length > 0;
  if (isRecording()){
    actionBtn.textContent = "⛔";
    actionBtn.title = "Parar gravação";
    actionBtn.classList.remove('mic');
  } else if (hasText){
    actionBtn.textContent = "✈️";
    actionBtn.title = "Enviar mensagem";
    actionBtn.classList.remove('mic');
  } else {
    actionBtn.textContent = "🎤";
    actionBtn.title = "Gravar áudio";
    actionBtn.classList.add('mic');
  }
}

/* ===== Controles do atendente ===== */
const btnProximo = document.getElementById("btnProximo");
const btnTimer = document.getElementById("btnTimer");
const endBtn = document.getElementById("endBtn");
if (ROLE !== "atendente") { btnProximo.style.display = "none"; btnTimer.style.display = "none"; }
btnProximo.addEventListener("click", ()=> socket.emit("next_in_queue"));
btnTimer.addEventListener("click", ()=>{
  if (cronometro) {
    pararCronometro();
    btnTimer.innerHTML = '<span class="dot"></span> Iniciar tempo';
    btnTimer.classList.remove("stop");
  } else {
    iniciarCronometro();
    btnTimer.innerHTML = '<span class="dot"></span> Parar tempo';
    btnTimer.classList.add("stop");
  }
});
endBtn.addEventListener("click", ()=> socket.emit("end_conversation"));

/* ===== TAROT (intacto) ===== */
const DECK = [
  {n:0, nome:"O Louco", img:'cards/o-louco.jpg'},
  {n:1, nome:"O Mago", img:'cards/o-mago.jpg'},
  {n:2, nome:"A Sacerdotisa", img:'cards/a-sacerdotisa.jpg'},
  {n:3, nome:"A Imperatriz", img:'cards/a-imperatriz.jpg'},
  {n:4, nome:"O Imperador", img:'cards/o-imperador.jpg'},
  {n:5, nome:"O Papa", img:'cards/o-papa.jpg'},
  {n:6, nome:"Os Enamorados", img:'cards/os-enamorados.jpg'},
  {n:7, nome:"O Carro", img:'cards/o-carro.jpg'},
  {n:8, nome:"A Força", img:'cards/a-forca.jpg'},
  {n:9, nome:"O Eremita", img:'cards/o-eremita.jpg'},
  {n:10, nome:"A Roda da Fortuna", img:'cards/a-roda-da-fortuna.jpg'},
  {n:11, nome:"A Justiça", img:'cards/a-justica.jpg'},
  {n:12, nome:"O Enforcado", img:'cards/o-enforcado.jpg'},
  {n:13, nome:"A Morte", img:'cards/a-morte.jpg'},
  {n:14, nome:"A Temperança", img:'cards/a-temperanca.jpg'},
  {n:15, nome:"O Diabo", img:'cards/o-diabo.jpg'},
  {n:16, nome:"A Torre", img:'cards/a-torre.jpg'},
  {n:17, nome:"A Estrela", img:'cards/a-estrela.jpg'},
  {n:18, nome:"A Lua", img:'cards/a-lua.jpg'},
  {n:19, nome:"O Sol", img:'cards/o-sol.jpg'},
  {n:20, nome:"O Julgamento", img:'cards/o-julgamento.jpg'},
  {n:21, nome:"O Mundo", img:'cards/o-mundo.jpg'}
];
const board = document.getElementById("board"); let selecionadas = [];
function cryptoRandomInt(maxExclusive){ const c=window.crypto||window.msCrypto; if(!c) return Math.floor(Math.random()*maxExclusive); const a=new Uint32Array(1); c.getRandomValues(a); return a[0]%maxExclusive; }
function shuffleCrypto(arr){ for(let i=arr.length-1;i>0;i--){ const j=cryptoRandomInt(i+1); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
function sortear(n){ const idx=Array.from(DECK.keys()); shuffleCrypto(idx); return idx.slice(0,n); }
function montarCarta(deckIndex){
  const data = DECK[deckIndex];
  const slot = document.createElement("div"); 
  slot.className="slot";
  const card = document.createElement("div"); 
  card.className="card"; 
  card.tabIndex=0;

  const back = document.createElement("div"); 
  back.className="face back";
  const backImg = document.createElement("img");
  backImg.src = "cards/back.png";  backImg.alt = "Verso";
  backImg.decoding = "async"; backImg.loading  = "eager";
  backImg.style.width = "100%"; backImg.style.height = "100%"; backImg.style.objectFit = "cover";
  back.appendChild(backImg);

  const front = document.createElement("div"); 
  front.className="face front";
  const img = document.createElement("img");
  img.alt = data.nome; img.src = data.img;
  img.style.width = "100%"; img.style.height = "100%"; img.style.objectFit = "cover";
  front.appendChild(img);

  const flip = ()=>{ card.classList.toggle("flipped"); };
  card.addEventListener("click", flip);
  card.addEventListener("keydown", (e)=>{ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); flip(); } });

  card.appendChild(back); 
  card.appendChild(front);
  slot.appendChild(card);
  return slot;
}
function renderBoard(){ board.innerHTML=""; selecionadas.forEach((i)=> board.appendChild(montarCarta(i))); }
(function initTarot(){ selecionadas = sortear(6); renderBoard(); })();

/* ===== PRINT ===== */
const TARGET_WIDTH = 320;
async function downscaleDataUrl(dataUrl, targetW = TARGET_WIDTH){
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const ratio = Math.min(targetW / img.width, 1);
      const canvas = document.createElement('canvas');
      canvas.width  = Math.round(img.width  * ratio);
      canvas.height = Math.round(img.height * ratio);
      canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);
      resolve(canvas.toDataURL('image/png'));
    };
    img.src = dataUrl;
  });
}
document.getElementById("btnTarotPrint").addEventListener("click", async ()=>{
  const target = document.querySelector("#lenRoot");
  try{
    const canvas = await html2canvas(target, { backgroundColor: null, scale: 1 });
    const raw = canvas.toDataURL("image/png");
    const thumb = await downscaleDataUrl(raw, TARGET_WIDTH);
    const id = genUID();
    addImageMessage(thumb, ROLE === "atendente" ? "attendant" : "client", "Leitura de Tarot", id, false);
    history.push({ t:"img", sender: ROLE === "atendente" ? "attendant" : "client", dataUrl: thumb, alt: "Leitura de Tarot", id, seen:false }); saveHistory();
    socket.emit("chat_image", { dataUrl: thumb, alt: "Leitura de Tarot", id });
  }catch(err){
    console.error("Falha ao gerar print:", err);
    addMessage("Não foi possível gerar o print das cartas neste momento.", ROLE === "atendente" ? "attendant" : "client");
    history.push({ t:"text", sender: ROLE === "atendente" ? "attendant" : "client", text: "Não foi possível gerar o print das cartas neste momento." }); saveHistory();
  }
});
document.getElementById("btnTarotShuffle").addEventListener("click", ()=>{ selecionadas = sortear(6); renderBoard(); });

/* ===== Sair da fila ao fechar (cliente) ===== */
function notifyLeavingQueue(){
  try{
    if (ROLE === "cliente" && !isPaired) {
      socket.emit("leave_queue", { uid: UID, room: ROOM });
      socket.emit("queue_sync", { room: ROOM });
    }
  }catch(e){}
}
window.addEventListener("beforeunload", notifyLeavingQueue);
window.addEventListener("pagehide", notifyLeavingQueue);

/* ===== Util ===== */
function genUID(){ if (crypto && crypto.randomUUID) return crypto.randomUUID(); return Date.now()+"-"+Math.random().toString(36).slice(2); }
</script>
</body>
</html>
